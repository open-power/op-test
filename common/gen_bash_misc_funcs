#!/bin/bash
# 2011/10/08 This file may be sourced in order to define basic bash miscellaneous functions like calc, max_i, add_trailing_char, etc.

# Change log:
# 2014/07/17 Mike Walsh (xzy0065) - build_cmd_buf: Change to handle strings with single quotes.
# 2014/07/23 Mike Walsh (xzy0065) - build_cmd_buf: I added "-r" to preserve back-slashes read from the file.

# It is the user program's responsibility to source the following files whose functions are used in this file.
# gen_bash_print_funcs
# gen_bash_valid_funcs
# gen_bash_list_funcs


# This creates a variable named <source file base name>_owner and assigns it the value of the owner.
eval ${BASH_SOURCE##*/}_owner=\"Michael Walsh\"
# Reference this variable as shown in the following examples.
# local var_name=${BASH_SOURCE##*/}_owner
# print_var "${var_name}"
# echo "${!var_name}"

# These variables are defined for use by programs and functions which may need to grep for a time-stamp that has the format generated by print_time.
valid_alpha_time_zone_regex='[A-Z]{3}'
valid_year_regex='[0-9]{4}'
valid_month_regex='(0[1-9]|1[0-2])'
valid_day_of_month_regex='([0][1-9]|[12][0-9]|3[0-1])'
valid_hour_24_regex='([0-1][0-9]|[2][0-3])'
valid_minute_regex='([0-5][0-9])'
valid_second_regex='([0-5][0-9])'
valid_status_date_regex="^#\(${valid_alpha_time_zone_regex}\) ${valid_year_regex}/${valid_month_regex}/${valid_day_of_month_regex} ${valid_hour_24_regex}:${valid_minute_regex}:${valid_second_regex}"


rcmd_gen_timeout=60


# Note: I moved bash_regex_op_valid and regexp to gen_bash_print_funcs.  See comments there.

# This is needed to be able to source this file if the file contains extglob expressions.
shopt -s extglob

################################################################################
function calc {

  # This function will evaluate arithmetic and boolean expressions and print the results to std out.  This function is a wrapper for the bc command.
  # Example uses/results:
  # calc 4*5
  # 20
  #
  # calc 4/5
  # .8000
  #
  # calc '4>5'
  # 0
  # (i.e. false, 4 is not greater than 5)
  # calc '4==4'
  # 1
  # (i.e. true, 4 is equal to 4)

  local temp_misc_file=/tmp/${FUNCNAME}_${RANDOM}_${RANDOM}
  local ret_value=0

  if FSP_machine ; then
    # FSPs don't have "bc" so I'll use awk instead.
    awk "BEGIN{ print $1 }" 2>$temp_misc_file
  else
    echo "scale=${scale:=4}; $1" | bc 2>$temp_misc_file
  fi
  if [ -s $temp_misc_file ] ; then
    cat $temp_misc_file
    ret_value=1
  fi

  rm $temp_misc_file
  return $ret_value

}
################################################################################



################################################################################
function max_i {
  # NOTE: We will not use the print_func_name and print_call_stack functions ever because calling functions depend on correct output from max_i.  

  # This function will print the greater of the 2 integers passed to it.

  [ $1 -gt $2 ] && echo $1 || echo $2

}
################################################################################



#(CDT) 2014/10/07 18:02:31 - Issuing: for (( ix=0 ; ix < 100000 ; ix++ )) ; do var1=tUlEtA ; change_case var1 1 ; done
# total_seconds:               6.931468000
# seconds_each:                0.000069314
# count_per_second:            14427
# var1:                        TULETA
################################################################################
function change_case {
  # local var_name=${1}
  # local to_upper=${2:-0}

  if (( ${2} )) ; then
    eval "${1}=\${${1}^^}" 2>/dev/null && return
  else
    eval "${1}=\${${1},,}" 2>/dev/null && return
  fi

  # This function will change the case of every character in the string found in the variable named in var_name.  to_upper indicates whether the change is from lower to upper or vice verse.  This function will make the change faster than doing it like this:
  # var=$(echo "${var}" | tr "[:upper:]" "[:lower:]")

  # Note: If we ever go to bash 4.x...
  # ${string,,} returns string converted to lower.  ${string^^} returns string converted to upper.

  local _var_=${!1}
  local upper_case="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  local lower_case="abcdefghijklmnopqrstuvwxyz"
  local from_buf to_buf ix

  if (( ${2} )) ; then
    from_buf=${lower_case}
    to_buf=${upper_case}
  else
    from_buf=${upper_case}
    to_buf=${lower_case}
  fi

  local length=${#from_buf}
  # Go through each letter in from_buf and use var substition to replace every instance of it in the caller's variable with the corresponding value in to_buf.
  for (( ix=0; ix < length; ix++ )) ; do
    _var_="${_var_//${from_buf:$ix:1}/${to_buf:$ix:1}}"
  done

  eval ${1}=\"\${_var_}\"

}
################################################################################



################################################################################
function add_trailing_char {
  #local string_var_name="${1}"
  #local char="${2:-/}"

  # This function will add "char" to the end of the string if it is not already present.

  #eval ${1}=\"\${!1%${char}}${char}\"
  eval ${1}=\"\${!1%${2:-/}}${22:-/}\"

  # 2012/02/02 Perf tuned.
  # local string=${!string_var_name}
  # string="${string%${char}}"
  # string="${string}${char}"
  #  eval ${string_var_name}=\"${string}\"

}
################################################################################



# Perf data:
# #(CDT) 2013/06/07 15:21:48.282580 -    0.016350 - Issuing: for (( ix=0 ; ix < 10000 ; ix++ )) ; do remove_leading_chars ipl_type_desc_required ' ' ; done
# total_seconds:                                    1.053143000
# seconds_each:                                     0.000105314
# count_per_second:                                 9495
################################################################################
function remove_leading_chars {
  # local var_name="${1}"
  # local char="${2:- }"

  # This function will remove as many "char" characters as are present at the beginning of the string whose variable name is passed in var_name.

  shopt -s extglob

  local cmd_buf
  cmd_buf="${1}='${!1##*(${2})}'"
  #issuing
  eval "${cmd_buf}"

}
################################################################################



# #(CDT) 2015/05/14 16:37:24 - Issuing: for (( ix=0 ; ix < 10000 ; ix++ )) ; do remove_cr_lf output ; done
# total_seconds:               1.458199000
# seconds_each:                0.000145819
# count_per_second:            6858
################################################################################
function remove_cr_lf {
  # local var_name="${1}" ; shift
  # local all="${1:-0}" ; shift
  # local replace_string="${1}" ; shift

  # This function will remove carriage returns and line feeds from the variable named in var_name.
  # If "all" is set, all cr/lfs will be removed from the variable.  Otherwise, only the trailing cr/lf will be removed.

  # Perf note: I had faster run times when using a local variable than when I tried to copy the result directly back to caller's variable.
  if (( ${2:-0} )) ; then
    local _loc_rcrlf_buffer_=${!1//[$'\n'$'\r']/${3}}
  else
    local _loc_rcrlf_buffer_=${!1%%+([$'\n'$'\r'])}"${3}"
  fi

  eval ${1}=\${_loc_rcrlf_buffer_}

}
################################################################################



################################################################################
function remove_trailing_chars {
  # local var_name="${1}"
  # local char="${2:- }"

  # This function will remove as many "char" characters as are present at the beginning of the string whose variable name is passed in var_name.

  shopt -s extglob

  local cmd_buf
  cmd_buf="${1}='${!1%%*(${2})}'"
  #issuing
  eval "${cmd_buf}"

}
################################################################################



################################################################################
function trim_chars {
  # local var_name="${1}"
  # local char="${2:- }"

  # This function will remove as many "char" characters as are present at the beginning and at the end of the string whose variable name is passed in var_name.

  remove_leading_chars ${1} "${2}"
  remove_trailing_chars ${1} "${2}"

}
################################################################################



################################################################################
function get_status_file_start_end_time {
  local file_path="${1}" ; shift || :
  local start_time_var="${1}" ; shift || :
  local end_time_var="${1}" ; shift || :
  local use_end_time_entry="${1:-1}" ; shift || :
  local quiet="${1:-1}" ; shift || :

  # This function will get the start and end time stamps from a status file.  If start_time_var and end_time_var are provided, the results will be put in those variables.  Otherwise, they will be written to standard output.
  # use_end_time_entry means that the last stamp written to the file is what will be retrieved.  Otherwise, this function will get the last change date via the stat command.

  local _loc_start_time_
  local _loc_end_time_
  local rc
  local cmd_buf

  if [ ! -z "${start_time_var}" ] && [ -z "${end_time_var}" ] ; then
    { print_error ; echo "Programmer error: If you specify a value for start_time_var then you must also specify one for end_time_var."; } | process_error_message
    return 1
  fi

  # Find the first entry in the file that begins with something like "#(CDT) " where CDT is any 3 uppercase characters (this field is the time zone).
  cmd_buf="_loc_start_time_=\$(egrep -m 1 --text \"^#\([A-Z]{3}\) \" $file_path 2>/dev/null)"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}
  rc=${?}
  case "${rc}" in
    "1")
      { print_error ; echo "File ${file_path} has no time stamps."; } | process_error_message
      return 1
      ;;
    "2")
      valid_file_path file_path || return 1
      ;;
   esac

  _loc_start_time_=${_loc_start_time_:1:25}
  _loc_start_time_=${_loc_start_time_//[()]/}

  if (( use_end_time_entry )) ; then
    # Find the last entry in the file that begins with something like "#(CDT) " where CDT is any 3 uppercase characters (this field is the time zone).
    cmd_buf="_loc_end_time_=\$(tac $file_path | egrep -m 1 --text \"^#\([A-Z]{3}\) \" | cut -c1-26 | sed -re \"s/[#()]//g\")"
  else
    # Get the end time using the stat command.  We assume the value obtained is expressed in terms of local time.
    local zone=$(date +%Z)
    cmd_buf="_loc_end_time_=\"${zone} \"\$(stat $file_path | grep Change | cut -f 2- -d ' ' | cut -f 1 -d . | sed -re \"s#-#/#g\")"
  fi
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}

  if [ -z "${start_time_var}" ] ; then
    echo ${_loc_start_time_}
    echo ${_loc_end_time_}
  else
    eval ${start_time_var}=\"${_loc_start_time_}\"
    eval ${end_time_var}=\"${_loc_end_time_}\"
  fi

}
################################################################################



################################################################################
function calc_runtime {
  local File_name="${1}"
  local Runtime_var_name="${2}"
  local use_end_time_entry="${3:-1}"
  local seconds_var="${4}"
  local quiet="${5:-1}"

  # This function will calculate the runtime of a program based on the first date entered in $File_name and, depending on the value of use_end_time_entry, ...
  # - The last date entered in $File_name or...
  # - The change date returned by "stat".
  # This is intended only for programs that use the print_time function frequently when logging their activities (print_time is a function found in gen_bash_funcs).
  # The result will be put in the caller's variable whose name is in $Runtime_var_name.
  # Also, this is not intended to deal with programs that run for more than 1 month.

  case "${File_name}" in "")
    valid_value File_name || return 1
    ;;
  esac
  case "${Runtime_var_name}" in "")
    valid_value Runtime_var_name || return 1
    ;;
  esac
  case "${use_end_time_entry}" in !("[01]"))
    valid_boolean use_end_time_entry || return 1
    ;;
  esac

  local start_time
  local start_time_secs
  local end_time
  local end_time_secs
  local Runtime_days
  local Runtime_hms

  # Note that all times are converted to UTC before doing any arithmetic.  This should get us accurate results if the zone changes while the file is being written (going from daylight saving to standard, etc.).
  cmd_buf="get_status_file_start_end_time $File_name start_time end_time ${use_end_time_entry} ${quiet}"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf} || return 1

  cmd_buf="start_time_secs=\$(date -u -d \"$start_time\" +%s)"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}

  #print_var_list "start_time start_time_secs"

  cmd_buf="end_time_secs=\$(date -u -d \"$end_time\" +%s)"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}

  local _loc_diff_secs_
  let _loc_diff_secs_=end_time_secs-start_time_secs

  cmd_buf="Runtime_days=\$(date -d \"2000/01/01 + ${_loc_diff_secs_} secs\" +\"%d\")"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}
  # Remove leading 0 to keep the subsequent let statement from interpreting it as octal.  Assumption: The value returned by the preceding date command will always be 2 digits.
  Runtime_days=${Runtime_days#0}
  let Runtime_days=Runtime_days-1
  cmd_buf="Runtime_hms=\$(date -d \"2000/01/01 + ${_loc_diff_secs_} secs\" +\"%H:%M:%S\")"
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}

  # print_var_list "start_time end_time start_time_secs end_time_secs _loc_diff_secs_"

  cmd_buf="${Runtime_var_name}=\"\$(printf \"%02i %s\" $Runtime_days $Runtime_hms)\""
  (( ! quiet )) && issuing >&2
  eval ${cmd_buf}

  if [ ! -z "${seconds_var}" ] ; then eval ${seconds_var}=${_loc_diff_secs_} ; fi

}
################################################################################



if ! test "${epoch+defined}" ; then
  readonly epoch="1970-01-01 UTC"
fi
if ! test "${sql_date_fmt+defined}" ; then
  readonly sql_date_fmt="%Y-%m-%d-%H.%M.%S.000000"
fi
if ! test "${prt_date_fmt+defined}" ; then
  readonly prt_date_fmt="#(%Z) %Y/%m/%d %H:%M:%S"
fi
if ! test "${cur_time_keyword+defined}" ; then
  readonly cur_time_keyword='[now]'
fi

# #(CDT) 2014/04/11 13:50:50 - Issuing: for (( ix=0 ; ix < 1000 ; ix++ )) ; do sql_date_to_std "2014-04-12-09.42.37.000000" std_date ; done
# total_seconds:               0.231898000
# seconds_each:                0.000231898
# count_per_second:            4312
################################################################################
function sql_date_to_std {
  local src_date="${1}" ; shift || :
  local targ_date_var="${1}" ; shift || :
  local strip_microseconeds="${1:-1}" ; shift || :

  # This function will convert an sql date to the kind of date produced by print_time.  Example:
  # 2012-11-08-17.57.08.000000
  # to
  # 2012/11/08 17:57:08
  #
  # 2012/12/14 Change: If targ_date_var is blank, the answer is written to stdout.  Otherwise, it is put in the variable named in targ_date_var.

  if (( ${#src_date} == 0 )) ; then
    { print_error ; echo "Parameter \"src_date\" has an invalid value of \"${src_date}\"." ; } | process_error_message
    return 1
  fi

  # Copy to local var for easier manipulations.
  local _loc_source_date_=${src_date}
  local time_width

  (( strip_microseconeds )) && time_width=8 || time_width=15

  local microseconds=${_loc_source_date_##*.}
  local max_ms_length=6
  if (( ${#microseconds} > max_ms_length )) ; then
    { print_error ; echo "The microseconds portion of date \"${src_date}\" is \"${microseconds}\".  This value exceeds ${max_ms_length} characters in length and is therefore invalid."; } | process_error_message
    return 1
  fi

  # Strip the microseconds off.
  _loc_source_date_=${_loc_source_date_%.*}
  # Replace dots with colons.
  _loc_source_date_=${_loc_source_date_//./:}
  # Put microseconds back on if requested by user.
  (( ! strip_microseconeds )) && _loc_source_date_=${_loc_source_date_}.${microseconds}
  # Replace dash with slash.
  _loc_source_date_=${_loc_source_date_//-/\/}
  # Replace date/time separator with space.
  _loc_source_date_="${_loc_source_date_:0:10} ${_loc_source_date_:11:${time_width}}"

  if [ -z "${targ_date_var}" ] ; then
    echo ${_loc_source_date_}
  else
    eval ${targ_date_var}=\"${_loc_source_date_}\"
  fi

}
################################################################################



################################################################################
function std_to_sql_date {
  local src_date="${1}" ; shift || :
  local targ_date_var="${1}" ; shift || :

  # This function will convert the kind of date produced by print_time to an sql date.  Example:
  # 2012/11/08 17:57:08
  # to
  # 2012-11-08-17.57.08.000000
  #
  # 2012/12/14 Change: If targ_date_var is blank, the answer is written to stdout.  Otherwise, it is put in the variable named in targ_date_var.

  if (( ${#src_date} == 0 )) ; then
    { print_error ; echo "Parameter \"src_date\" has an invalid value of \"${src_date}\"." ; } | process_error_message
    return 1
  fi

  # Copy to local var for easier manipulations (removing time zone if present).
  local _loc_source_date_=${src_date#* }
  # Convert slashes to dashes.
  _loc_source_date_=${_loc_source_date_//\//-}
  # Convert space to dash.
  _loc_source_date_=${_loc_source_date_// /-}
  # Convert colongs to dots and add microseconds.
  _loc_source_date_=${_loc_source_date_//:/.}.000000

  if [ -z "${targ_date_var}" ] ; then
    echo ${_loc_source_date_}
  else
    eval ${targ_date_var}=\"${_loc_source_date_}\"
  fi

}
################################################################################



################################################################################
function seconds {
  local date1="${1}" ; shift || :

  # This function will convert the given date to seconds since the epoch.  date1 may contain any value that is acceptable for the "-d" date parm.

  date -d "${date1}" +%s

}
################################################################################



################################################################################
function seconds_to_date {
  local seconds="${1}" ; shift || :

  # This will convert seconds-since-the-epoch to a date.  Additional parms (such as format) will be passed directly to the date program.

  date -d "${epoch} + ${seconds} seconds" "${@}"

}
################################################################################



################################################################################
function date_math {

  # date_math will do math with dates.  Think of it as analogous to the "let" bash built in.  However, unlike with the "let" built in, all expression arguments must be delimited by a space.
  # The right most parameter can be a format parameter which will be passed to the date function.  This will cause your output to be formatted the way you like.  Without this parameter, your output will be in "seconds-since-the-epoch" format.
  # Examples:
  # date_math next_date = "(CST) 2012/12/14 16:35:32" + 600 "+${prt_date_fmt}"
  # date_math cur_date = "$(sql_date_to_std ${cur_date})" + $((interval_mins*60)) +"${sql_date_fmt}"

  local cmd_buf
  local token
  local expression
  local lvalue="${1}"
  local format
  # 2015/07/09 Mike Walsh (xzy0065) - Note: I made a global readonly version of valid_bash_var_regex in gen_bash_print_funcs.  When time allows, you may want to switch from using this local version to using the global one.
  local valid_bash_var_regex="[_a-zA-Z][_a-zA-Z0-9]*"

  if ! regexp "${lvalue}" "^${valid_bash_var_regex}$" ; then
    { print_error ; echo "The first parameter to this function is \"${1}\".  This is not a valid bash variable name as is required." ; } | process_error_message
    return 1
  fi

  if [ "${2}" != "=" ] ; then
    { print_error ; echo "The second parameter to this function is \"${2}\".  It should be an assignment operator (\"=\")." ; } | process_error_message
    return 1
  fi

  while [ $# -gt 0 ] ; do
    token="${1}"
    if regexp "${token}" "%" ; then
      format="${token}"
    elif ! ( printf "%i" "${token}" >/dev/null 2>&1 || regexp "${token}" "^(${valid_bash_var_regex}|=|\+|\*|/)$" ) ; then
      cmd_buf="token=\$(seconds '${token}')"
      #issuing
      eval ${cmd_buf}
      expression=${expression}${token}
    else
      expression=${expression}${token}
    fi

    shift || :
  done

  cmd_buf="let ${expression}"
  #issuing
  eval ${cmd_buf}

  if [ ! -z "${format}" ] ; then
    cmd_buf="${lvalue}=\$(seconds_to_date ${!lvalue} \"${format}\")"
    #issuing
    eval ${cmd_buf}
  fi

}
################################################################################



################################################################################
function date_subtract {
  local date1="${1}"
  local date2="${2}"

  # This function will subtract date2 from date1 and print the result to stdout.  It will print an error and return non zero if the caller does not pass a valid date.

  valid_value date1 "" || return 1
  valid_value date1 "" || return 1

  local num_secs

  date1_secs=$(date -u -d "${date1}" +"%s") || return 1
  date2_secs=$(date -u -d "${date2}" +"%s") || return 1

  let num_secs=date1_secs-date2_secs

  echo "${num_secs}"

}
################################################################################



################################################################################
function incr {
  local var_name="${1}" ; shift || :
  local incr_value="${1:-1}" ; shift || :

  if (( ${#var_name} == 0 )) ; then
    { print_error ; echo " Parameter \"var_name\" has an invalid value of \"${var_name}\"." ; } | process_error_message
    return 1
  fi

  if ! printf "%i" "${incr_value}" >/dev/null 2>&1 ; then
    { print_error ; echo " Parameter \"incr_value\" has an invalid value of \"${incr_value}\".  It must contain an integer." ; } | process_error_message
    return 1
  fi

  local cmd_buf

   cmd_buf="let ${var_name}=${!var_name}+${incr_value}"
   #issuing
   eval ${cmd_buf}

}
################################################################################


if ! test "${seconds_in_day+defined}" ; then
  readonly seconds_in_day=86400
  readonly seconds_in_hour=3600
  readonly seconds_in_minute=60
fi

################################################################################
function calc_min_time_unit {
  local total_seconds="${1}" ; shift || :
  local unit_var="${1}" ; shift || :

  # This function will determine the minimum unit value (days:hours:minutes:seconds) that is appropriate for the total_seconds value passed.  It will put this value in the variable named in unit_var.  Examples:
  # Seconds     Value           Unit
  # -------     -----------     -------
  # 1           1               seconds
  # 60          01:00           minutes
  # 86400       1 00:00:00      days

  [ ! -z "${total_seconds}" ] && printf "%i\n" "${total_seconds}" >/dev/null 2>&1
  if [ "$?" != "0" ] ; then
    { print_error ; echo "Function ${FUNCNAME}, line ${LINENO}: For \"total_seconds\" you specified an invalid value of \"${total_seconds}\".  You must pass an integer." ; print_call_stack; } >&2
    return 1
  fi

  if [ -z "${unit_var}" ] ; then
    { print_error "Function ${FUNCNAME}, line ${LINENO}: Parameter \"unit_var\" has an invalid value of \"${unit_var}\"." ; echo ; print_call_stack ; } >&2
    return 1
  fi

  if (( total_seconds < 0 )) ; then
    let total_seconds=total_seconds*-1
  fi

  if (( total_seconds < seconds_in_minute )) ; then
    eval $unit_var=seconds
  elif (( total_seconds < seconds_in_hour )) ; then
    eval $unit_var=minutes
  elif (( total_seconds < seconds_in_day )) ; then
    eval $unit_var=hours
  else
    eval $unit_var=days
  fi

}
################################################################################



################################################################################
function convert_secs_to_dhms {
  local total_seconds="${1}" ; shift || :
  local unit="${1:-days}" ; shift || :
  local buffer_var="${1}" ; shift || :
  local include_units="${1:-0}" ; shift || :
  local days_var="${1}" ; shift || :
  local hours_var="${1}" ; shift || :
  local minutes_var="${1}" ; shift || :
  local seconds_var="${1}" ; shift || :

  # This function converts total seconds to "dd hh:mm::ss" format and print the result to stdout.  It will print an error and return non zero if the caller does not pass a valid integer for total_seconds.
  # The unit may be set to the following values:
  # days    (default)
  # hours
  # minutes
  # seconds
  # The unit value indicates whether your result should be expressed in days, hours, minutes or seconds.  For example, for total_seconds of 86400:
  # unit        result
  # ----------- ------------
  # days        01 00:00:00
  # hours       24:00:00
  # minutes     1440:00
  # seconds     86400

  # If you provide a variable name in buffer_var, the result will be put into your variable.  The broken-out values will be provided (sans leading zeroes) in any of the variables you name in days_var, hours_var, minutes_var or seconds_var.
  # include_units means you wish to have the unit value as part of the output.  Examples:
  #  1 second
  #  2 seconds
  #  01 00:00:00 day

  # 2012/02/27 Perf tuning.
  # valid_integer total_seconds || return 1
  [ ! -z "${total_seconds}" ] && printf "%i\n" "${total_seconds}" >/dev/null 2>&1
  if [ "$?" != "0" ] ; then
    { print_error ; echo "Function ${FUNCNAME}, line ${LINENO}: For \"total_seconds\" you specified an invalid value of \"${total_seconds}\".  You must pass an integer." ; print_call_stack; } >&2
    return 1
  fi

  local sign=" "

  if (( total_seconds < 0 )) ; then
    sign="-"
    let total_seconds=total_seconds*-1
  fi

  # 2012/07/05 Perf: Handle bad unit as a case statement.

  local unit_num
  case $unit in
    days)
      unit_num=4
      ;;
    hours)
      unit_num=3
      ;;
    minutes)
      unit_num=2
      ;;
    seconds)
      unit_num=1
      ;;
    *)
      { print_error ; echo "Function ${FUNCNAME[1]}, line ${BASH_LINENO[0]}: Variable \"unit\" has a value of \"${unit}\" which was not found in the valid value list (\"$valid_time_unit_values\")." ; print_call_stack ; } >&2
      return 1
      ;;
  esac

  local _loc_days_
  local _loc_hours_
  local _loc_minutes_
  local _loc_seconds_

  if (( unit_num >= 4 )) ; then
    let _loc_days_=$total_seconds/$seconds_in_day
    let total_seconds=$total_seconds%$seconds_in_day
  fi
  if (( unit_num >= 3 )) ; then
    let _loc_hours_=$total_seconds/$seconds_in_hour
    let total_seconds=$total_seconds%$seconds_in_hour
  fi
  if (( unit_num >= 2 )) ; then
    let _loc_minutes_=$total_seconds/$seconds_in_minute
    let total_seconds=$total_seconds%$seconds_in_minute
  fi
  if (( unit_num > 1 )) ; then
    let _loc_seconds_=$total_seconds%$seconds_in_minute
  elif (( unit_num == 1 )) ; then
    _loc_seconds_=$total_seconds
  fi

  local lf_string
  if [ -z "${buffer_var}" ] ; then
    lf_string="\\n"
  else
    lf_string=""
  fi

  local print_unit_string=""
  if (( include_units )) ; then
    local print_unit=${unit}
    case $unit in
      days)
        (( _loc_days_ == 1 )) && print_unit=${print_unit%s}
        ;;
      hours)
        (( _loc_hours_ == 1 )) && print_unit=${print_unit%s}
        ;;
      minutes)
        (( _loc_minutes_ == 1 )) && print_unit=${print_unit%s}
        ;;
      seconds)
        (( _loc_seconds_ == 1 )) && print_unit=${print_unit%s}
        ;;
    esac
    print_unit_string=" ${print_unit}"
  fi

  if [ ! -z "${days_var}" ] ; then
    eval $days_var=\"$_loc_days_\"
  fi

  if [ ! -z "${hours_var}" ] ; then
    eval $hours_var=\"$_loc_hours_\"
  fi
  if [ ! -z "${minutes_var}" ] ; then
    eval $minutes_var=\"$_loc_minutes_\"
  fi
  if [ ! -z "${seconds_var}" ] ; then
    eval $seconds_var=\"$_loc_seconds_\"
  fi

  local _loc_buffer_

  [ "${#_loc_days_}" -lt 2 ] && _loc_days_="0${_loc_days_}"
  [ "${#_loc_hours_}" -lt 2 ] && _loc_hours_="0${_loc_hours_}"
  [ "${#_loc_minutes_}" -lt 2 ] && _loc_minutes_="0${_loc_minutes_}"
  [ "${#_loc_seconds_}" -lt 2 ] && (( unit_num > 1 )) && _loc_seconds_="0${_loc_seconds_}"

  if (( unit_num == 4 )) ; then
    _loc_buffer_="${sign}${_loc_days_} ${_loc_hours_}:${_loc_minutes_}:${_loc_seconds_}${print_unit_string}"
  elif (( unit_num == 3 )) ; then
    _loc_buffer_="${sign}${_loc_hours_}:${_loc_minutes_}:${_loc_seconds_}${print_unit_string}"
  elif (( unit_num == 2 )) ; then
    _loc_buffer_="${sign}${_loc_minutes_}:${_loc_seconds_}${print_unit_string}"
  elif (( unit_num == 1 )) ; then
    _loc_buffer_="${sign}${_loc_seconds_}${print_unit_string}"
  fi

  if [ -z "${buffer_var}" ] ; then
    echo ${_loc_buffer_}
  else
    eval ${buffer_var}=\"${_loc_buffer_}\"
  fi

  return


# Old way...

  if (( unit_num == 4 )) ; then
    cmd_buf="printf \"%s%02i %02i:%02i:%02i${print_unit_string}${lf_string}\" \"${sign}\" $_loc_days_ $_loc_hours_ $_loc_minutes_ $_loc_seconds_"
  elif (( unit_num == 3 )) ; then
    cmd_buf="printf \"%s%02i:%02i:%02i${print_unit_string}${lf_string}\" \"${sign}\" $_loc_hours_ $_loc_minutes_ $_loc_seconds_"
  elif (( unit_num == 2 )) ; then
    cmd_buf="printf \"%s%02i:%02i${print_unit_string}${lf_string}\" \"${sign}\" $_loc_minutes_ $_loc_seconds_"
  elif (( unit_num == 1 )) ; then
    cmd_buf="printf \"%s%i${print_unit_string}${lf_string}\" \"${sign}\" $_loc_seconds_"
  fi

  if [ ! -z "${buffer_var}" ] ; then
    cmd_buf="${buffer_var}=\$($cmd_buf)"
  fi
  eval $cmd_buf

}
################################################################################



################################################################################
function pgid {

  # This function will print the process group to stdout.
  if [ "${op_system:=$(uname)}" == "AIX" ] ; then
    # Low priority to get this working for aix.
    return
  else
    # Make sure to strip spaces.
    # ps -opgid --no-headers $$ | sed -re "s/ //g"
    # This seems faster.
    echo $(ps -opgid --no-headers $$)
  fi

}
################################################################################



################################################################################
function build_cmd_buf {
  local our_parms_name="${1:-our_parms}"
  local additional_parms="${2}"
  local cmd_buf_name="${3:-cmd_buf}"

  # NOTE: This function assumes that exit_function has been set up with a cleanup of cleanup_file_list.

  # This function will take the our_parms array and additional_parms, process them and append them to cmd_buf.
  # This is designed for programs that are calling subordinate programs that take additional parms separated with " -- ".  There can be many levels of such programs:
  #
  # pgm1 -- <pgm2 parms> -- <pgm3 parms> -- <pgmN parms>
  #
  # This function is useful if the calling program has parms that it wants to intersperse with the user's additional parms.
  #
  # Example:  Assume caller's cmd_buf = "pgm1".  cmd_buf would contain this at the end of this function:
  #
  # pgm1 -- <our pgm2 parms> <user's pgm2 parms> -- <our pgm3 parms> <user's pgm3 parms>, etc.
  #
  # By specifying our parms first, the user has the chance to override with their parms.

  valid_value our_parms_name ":loc_our_parms" || return 1
  valid_value cmd_buf_name ":loc_cmd_buf" || return 1

  local cmd_buf2

  # Define local copies of parms and copy caller's values to them.  This is for ease of programming.
  local loc_cmd_buf="${!cmd_buf_name}"
  local loc_our_parms=()
  local num_our_parms

  cmd_buf2=num_our_parms=\${#${our_parms_name}[@]}
  eval $cmd_buf2

  # Copy caller's array to local array for ease of programming.
  local ix
  for (( ix = 0; ix < $num_our_parms; ix++ )) ; do
    cmd_buf2="loc_our_parms[$ix]=\${${our_parms_name}[$ix]}"
    eval $cmd_buf2
  done

  # Create temp file to contain user parms.
  local user_parm_file=/tmp/${PGM_NAME}_${FUNCNAME}_${RANDOM}_${RANDOM}
  # Corrected this error: /tmp/${USER:=$(whoami)} may not exist.
  #user_parm_file=/tmp/${USER:=$(whoami)}/${PGM_NAME}_user_parms_$$
  add_list_element $user_parm_file cleanup_file_list

  # The user separates each set of parms with a " -- ".  We separate them with a newline.
  echo "${additional_parms}" | sed -re "s/-- /--  /g" | sed -re "s/(^| )-- /\n/g" > ${user_parm_file}

  # Create user_parms array.  Populate it with the contents of our temp file.
  local user_parms=()
  ix=0
  local parm_line
  # 2014/07/23 Mike Walsh (xzy0065) - I added "-r" to preserve back-slashes read from the file.
  while read -r parm_line ; do
    user_parms[$ix]="${parm_line}"
    let ix=ix+1
  done < ${user_parm_file}
  { rm -f $user_parm_file ; remove_list_element $user_parm_file cleanup_file_list ; }

  num_user_parms=${#user_parms[@]}

  # For each level of parms, specify our parms first followed by user parms.  That way, they can override our parms.
  local loop_max=$(max_i $num_our_parms $num_user_parms)
  for (( ix = 0; ix < $loop_max; ix++ )) ; do
    if (( ix != 0 )) ; then
      loc_cmd_buf="${loc_cmd_buf} --"
    fi
    if [ ! -z "${loc_our_parms[$ix]}" ] ; then
      loc_cmd_buf="${loc_cmd_buf} ${loc_our_parms[$ix]}"
    fi
    if [ ! -z "${user_parms[$ix]}" ] ; then
      loc_cmd_buf="${loc_cmd_buf} ${user_parms[$ix]}"
    fi
  done

  # Put value in user's var.
  #cmd_buf2="${cmd_buf_name}='${loc_cmd_buf}'"
  # 2014/07/17 Mike Walsh (xzy0065) - Handle single quotes.
  cmd_buf2="${cmd_buf_name}='$(escape_quotes loc_cmd_buf single 1)'"
  eval $cmd_buf2

}
################################################################################



# 2012/01/13 Perf tuned
################################################################################
function find_char {
#  local char="${1}" ; shift || :
#  local buffer="${1}" ; shift || :

  # This function will search the buffer for the first occurrence of the character passed in char.  This function returns 0 if the char can be found in buffer and non-zero otherwise.

# [ "$buffer" != "${buffer/${char}/}" ]
  [ "${2}" != "${2/${1}/}" ]

}
################################################################################



if ! test "${comment_regex+defined}" ; then
  readonly comment_regex='^[[:blank:]]*#|^[[:blank:]]*$'
fi

################################################################################
function comment_help_text {
  local _loc_indent_="${1:-0}" ; shift || :
  local headers="${1:-1}" ; shift || :

  (( headers )) && printf "\n"
  printf "%-${_loc_indent_}s%s\n" "" "The following lines are interpreted as comment lines:"
  printf "%-${_loc_indent_}s%s\n" "" "- Any line consisting entirely of blanks or tabs."
  printf "%-${_loc_indent_}s%s\n" "" "- Any line consisting consisting of only blanks or tabs followed by a '#'."
  (( headers )) && printf "\n"

}
################################################################################



################################################################################
function my_read {
  local save_IFS="${IFS}"
  local IFS="${1:-${IFS}}" ; shift || :

  # This function gives several advantages over plain old read:
  # 1) It accepts the IFS (or field separator) parm as the first value.  IFS is declared as a local variable so your global IFS will not be altered.  So where you would have coded this:
  #
  # SAVE_IFS="${IFS}"
  # while { IFS=',' ; read field1 field2 filler ; } ; do
  #   # Restoring IFS so that parms are passed to functions correctly, etc.
  #   IFS="${SAVE_IFS}"
  #   ...
  # done < $my_file
  #
  # You may simply code this instead.
  # while my_read ',' field1 field2 filler ; do

  # 2) This function will remove carriage returns from the last specified variable.
  # 3) If global variable _mr_discard_comment_lines_ is set, this function will continue reading until either eof or until a non blank lines or comments line is found.  Comment lines are defined as follows:
  #   - A line consisting of only blanks or tabs.
  #   - A line consisting of only blanks or tabs followed by a '#' followed by anything else.

  # 

  [ "${IFS}" == "null" ] && IFS=""

  local cmd_buf

  if [ -z "${_mr_discard_comment_lines_}" -o "${_mr_discard_comment_lines_}" == "0" ] ; then
    read "${@}" || return "${?}"
  else 
    while (( 1 )) ; do
      read "${@}" || return "${?}"
      [ -z "${_mr_discard_comment_lines_}" ] && break
      # [[ "${!1}" =~ "${comment_regex}" ]] && continue || break
      regexp "${!1}" "${comment_regex}" && continue || break
    done
  fi

  # Restoring original IFS allows the user's IFS to contain an equal sign.
  IFS="${save_IFS}"

  # Remove any carriage returns from last variable

  # cmd_buf="${last_var_name}=\"\${${last_var_name}//$'\r'/}\""
  cmd_buf="${!#}=\"\${${!#}//$'\r'/}\""
  # issuing >&2
  eval ${cmd_buf}

}
################################################################################



################################################################################
function extract_date_from_status_line {
  local line="${1}"

  # This function will extract the date stamp from "line", remove the parenthesis and print it to stdout.  If it cannot obtain a valid date it will print a message to stderr and return non-zero.  The date has to be in the format that is generated by the "print_time" function.

  valid_value line "" || return 1
  local loc_date

  # Get the date and remove the parenthesis.  Example line:
  #(CDT) 2010/03/20 01:46:53 (UTC) 2010/03/20 06:46:53 - Retrieving Dump Control Block.
  loc_date=$(echo "${line}" | cut -c2-26 | sed -re "s/\(|\)//g")

  date -u -d "$loc_date" >/dev/null 2>&1
  if [ "$?" != "0" ] ; then
    { print_error ; echo "Function ${FUNCNAME}, line ${LINENO}: Could not extract a valid status date from the following line of text:" ; echo "${line}" ; echo ; } >&2
    print_call_stack >&2
    return 1
  fi

  echo $loc_date

}
################################################################################



################################################################################
function directional_egrep {
  local File_path="${1}"
  local Line_num="${2}"
  local search_direction="${3}"

  # This function will do a egrep for the caller but instead of looking at the entire file, it will only look at a portion of the file.  Line_num indicates the starting position.  If the search direction is forward, this function will egrep from Line_num to the end of the file.  If the search direction is backward, this function will search backward from Line_num to the beginning of the file.  In both cases line # "Line_num" is included in the text to be searched.

  # Because of the nature of this function, you cannot pass a list of files.
  # Any additional parms will be passed on to egrep.  Example call:
  #
  # directional_egrep /tmp/file1 5 "forward" -m 1 -n "dog"
  #
  # In this example the file /tmp/file1 is searched from line 5 onward for the expression "dog".  The additional parms (-m 1 -n) are passed to the egrep command.

  # Please note: If you pass "-n", the line numbers returned will be relative to "Line_num" moving forward or backward (according to search_direction).
  # This function will return 10 if there is a general error.  Otherwise, it will return the rc resulting from the grep.

  # 2014/12/04 Mike Walsh (xzy0065) - I changed this function to handle file paths with embedded spaces.

  local cmd_buf

  valid_file_path File_path || return 10
  valid_integer Line_num || return 10
  valid_value search_direction "" "forward:backward" || return 10

  shift 3 || :

  local parm_value
  #print_var_list "File_path Line_num search_direction"
  if (( DEBUG )) ; then
    {
      for (( ix=1; ix <= $# ; ix++ )) ; do
        parm_value="${!ix}"
        print_var parm_value
      done
    } >&2
  fi

  if [ "${search_direction}" == "backward" ] ; then
    cmd_buf="head -n $Line_num '$File_path' | tac | egrep \"\$@\""
  else
    cmd_buf="tail -n +$Line_num '$File_path' | egrep \"\$@\""
  fi

  # issuing >&2
  eval $cmd_buf

}
################################################################################



################################################################################
function get_nearest_time_stamp {
  local File_path="${1}"
  local Line_num="${2}"
  local search_direction="${3}"
  local time_var_name="${4}"

  # This function will get time stamp that is nearest to Line_num in File_path.  If you specify a search_direction of "backward", line # Line_num is included in the search.  If you specify a search_direction of "forward", line # Line_num is NOT included in the search.  If no time stamp can be found, this function will print a message to stderr and return non-zero.
  # This function only considers time stamps in the format produced by print_time.

  local cmd_buf

  # Validating parm values.
  valid_value File_path "" || return 1
  valid_value Line_num "" || return 1
  valid_value search_direction "" "forward:backward" || return 1
  valid_value time_var_name "" || return 1

  local Line_2

  if [ "${search_direction}" == "forward" ] ; then
    let Line_num=Line_num+1
  fi

  #cmd_buf="Line_2=\$(directional_egrep \"$File_path\" \"$Line_num\" \"${search_direction}\" -m 1 -a \"${valid_status_date_regex}\")"
  cmd_buf="Line_2=\$(directional_egrep \"$File_path\" \"$Line_num\" \"${search_direction}\" -m 1 -a '${valid_status_date_regex}')"
  #issuing >&2
  # Perf note: Normally I don't quote like this but it seems to make it run faster.  I'm guessing bash is trying to evaluate the regex when I don't quote.
  eval "${cmd_buf}"

  # Note: grep -a option means "Process a binary file as if it were text".
  cmd_buf="Line_2=\$(directional_egrep \"$File_path\" \"$Line_num\" \"${search_direction}\" -m 1 -a \"${valid_status_date_regex}\")"
  #issuing >&2
  eval ${cmd_buf}
  if [ -z "${Line_2}" ] ; then
    { print_error ; echo "Function ${FUNCNAME}, line ${LINENO}: Could not find a time stamp searching $search_direction from line $Line_num in file $File_path." ; } >&2
    print_call_stack >&2
    return 1
  fi
  #print_var_list "Line_2"

  # Because Line_2 may have quotes in it, it is necessary to avoid expanding it until the eval command runs.  That is why I put the escape char (\) before ${Line_2}.
  #cmd_buf="${time_var_name}=\$(extract_date_from_status_line \"\${Line_2}\" 2>/dev/null)"
  (( DEBUG )) && out_string="" || out_string=" 2>/dev/null"
  cmd_buf="${time_var_name}=\$(extract_date_from_status_line \"\${Line_2}\"${out_string})"
  # issuing >&2
  eval $cmd_buf || return 1

}
################################################################################



################################################################################
function sort_by_last_time_stamp {
  local sort_parms="${1}"

  # This function will sort the files passed to it by the last time stamp found in each file.  The time stamp we're speaking of is the standard time stamp generated by print_time.  Ex.:
  # #(CST) 2013/02/11 12:02:40

  # If the first parameter to this function is "-r", the sort will be reversed.  All subsequent parms to this function must be file path names.
  # Example calls:
  # sort_by_last_time_stamp ${file_list}
  # sort_by_last_time_stamp -r ${file_list}

  # Note: if the file has no time stamps in it, this function cannot determine where it ought to appear in the output.  Therefore, the file will not be included in the output at all.

  local file_path
  local cmd_buf
  local last_date

  if [ "${sort_parms}" == "-r" ] ; then
    shift
  else
    sort_parms=""
  fi

  for file_path in ${@} ; do
    # Perf: Fork each of these 2 allow them to run in parallel.
    {
      cmd_buf="last_date=\$(tac $file_path | grep -E -m 1 -o '${valid_status_date_regex}')"
      #(( ! quiet )) && issuing >&2
      eval ${cmd_buf}
      # If last_date is blank, the file has no time stamps in it.
      if [ ! -z "${last_date}" ] ; then
        echo "${last_date}@${file_path}"
      fi
    } &
  done | sort ${sort_parms} | cut -f 2 -d '@'

}
################################################################################



# Perf: 0.000215156 seconds.
################################################################################
function create_temp_file_name {

  # Perf: .00005
  # local temp_file_var="${1}"
  # local file_suffix="${2}"
  # local add_to_cleanup_file_list="${3:-1}"
  # local delimiter="${4:-:}"
  # local hidden="${5:-0}"
  # Perf: .00007

  # This function will create a temporary file name and put it in the variable named in temp_file_var.  The caller may specify a file_suffix to be included as the last part of the name.  If add_to_cleanup_file_list is set to 1, the file name will be added to the global cleanup_file_list.
  # The benefit of using this function is that your temp files will have a uniform name pattern that carries lots of information for help in debugging.
  # /tmp/<userid>/<program name>:<function name>:line_<line number>:pid_<pid>:<random number>:<any file suffix supplied by the caller>.

  # If temp_file_var contains a dir_path already, that will be used as the path for the temp file name. Otherwise, it will be /tmp/${USER}.
  # If hidden = 1, then the file name will have an initial dot ".".

  local dirpath
  if [ -z "${!1}" ] ; then
    dirpath=/tmp/${USER:-$(whoami 2>/dev/null || echo root)}/
  else
    # 2014/12/05 Mike Walsh (xzy0065) - Incorrect calculation of dirpath.
    # dirpath="${!1%/}/"
    dirpath="${!1%/*}/"
  fi

  # Perf: 0.000024701

  if [ ! -d "${dirpath}" ] ; then mkdir ${dirpath} || return 1 ; fi
  # Pef: 0.000027468

  # 2013/05/28 When using multi_cmd_func, which does asynchronous processing, it is more of an issue making sure that different subtasks do not get the same temp file name.  By adding 2 more calls to ${RANDOM}, I was able to call this function 1,000,000 times with no duplicate names.
  # Looks like the solution above still fails to produce unique names 100% of the time.  Adding code to get bashpid and use it if it is different from the pid.
  local BASHPID_string
  [ -z "${BASHPID}" ] && set_BASHPID
  [ "$$" != "${BASHPID}" ] && BASHPID_string="sub_pid_${BASHPID}${4:-:}"

  local hidden
  [ "${5}" == "1" ] && hidden="."

  eval ${1}=${dirpath}${hidden}${PGM_NAME:-${0##*\/}}${4:-:}${FUNCNAME[1]:-main}${4:-:}line_${BASH_LINENO[0]:-${LINENO}}${4:-:}pid_$$${4:-:}${BASHPID_string}${RANDOM}${RANDOM}${RANDOM}${4:-:}${2} 2>/dev/null || { { print_error "Function ${FUNCNAME}, line ${LINENO}: Parameter \"temp_file_var\" has an invalid value of \"${1}\".  The value must be a valid bash variable name." ; echo ; } | process_error_message ; return 1 ; }

  #print_var ${1}

  # Check add_to_cleanup_file_list...
  if [ "${3:-1}" != "0" ] ; then
    # add_list_element ${!1} cleanup_file_list || return 1
    [ -z "${cleanup_file_list}" ] && cleanup_file_list=${!1} || cleanup_file_list="${cleanup_file_list} ${!1}"
  fi

}
################################################################################



# Perf data:
# #(CDT) 2013/05/28 14:24:33.170376 -    0.002783 - Issuing: for (( ix=0 ; ix < 10000 ; ix++ )) ; do cleanup_temp_file "/tmp/csptest/scr_pgm11:main:line_137:pid_29329:30117128215374:" "1" 1 ; done
# total_seconds:                                    14.305993000
# seconds_each:                                     0.001430599
# count_per_second:                                 699
################################################################################
function cleanup_temp_file {
  local temp_file_list="${1}" ; shift || :
  local remove_from_cleanup_file_list="${1:-1}" ; shift || :
  local quiet="${1:-${quiet}}" ; shift || :
  local asynch_rm="${1:-1}" ; shift || :
  local max_attempts="${1:-1}" ; shift || :
  local sleep_interval="${1:-1}" ; shift || :

  # This function will cleanup temporary files.  This includes deleting the file and removing the file name from the cleanup_file_list.

  local temp_file
  local cmd_buf
  local ret_code=0
  local fork_string

  (( asynch_rm )) && fork_string=" &" || fork_string=""

  for temp_file in $temp_file_list ; do
    #cmd_buf="rm -f ${temp_file}"
    # 2013/05/28 Perf: do this asynchronously and trust that it will be done.
    #cmd_buf="rm -f ${temp_file}${fork_string}"
    # 2014/03/05 I saw this fail once due to "Connection timed out".  I'm adding a retry loop.
    cmd_buf="rm -rf ${temp_file}${fork_string}"
    local ix
    for (( ix=0; ix < ${max_attempts} ; ix++ )) ; do
      (( ! quiet )) && issuing
      eval ${cmd_buf} && break || ret_code=1
      sleep ${sleep_interval}
    done

    if (( remove_from_cleanup_file_list )) ; then
      cmd_buf="remove_list_element ${temp_file} cleanup_file_list \" \" back all"
      (( ! quiet )) && issuing
      eval ${cmd_buf} || ret_code=1
    fi
  done

  return $ret_code

}
################################################################################



################################################################################
function ascii_hex_to_char {
  local buffer_var="${1}" ; shift || :

  # This function will convert ascii hex to char.  Example, given this input:
  # 30392f30342f323031322031353a34333a3533
  # It will change the value to:
  # 09/04/2012 15:43:53

  if (( ${#buffer_var} == 0 )) ; then
    { print_error "Function ${FUNCNAME}, line ${LINENO}: Parameter \"buffer_var\" has an invalid value of \"${buffer_var}\"." ; echo ; } >&2
    print_call_stack >&2
    return 1
  fi

  local ix=0
  eval local length=\${#${buffer_var}}

  local cmd_buf="$buffer_var=\$(for (( ix=0; ix < length; ix+=2 )) ; do printf \"\\x\${${buffer_var}:\$ix:2}\" ; done)"
  #issuing
  eval $cmd_buf

}
################################################################################



# Perf info:
# total_seconds:               2.673712000
# seconds_each:                0.000267371
# count_per_second:            3740
################################################################################
function round_up {
  # local float="${1}"
  # local num_var="${2}"

  # This function will round a floating point number up to the next whole value.
  # Original value      Result
  # ------------------- ------
  # 2.50                3
  # 2.1                 3
  # 2.0                 2

  # If the caller provides a variable name in num_var, the result will be put into the variable.  Otherwise, the result will be printed to stdout.

  # Assign all the digits to the left of the decimal point to "whole".  If that turns out to be nothing, set whole to zero.
  local whole=${1%%.*} ; [ -z "${whole}" ] && whole=0

  local fraction
  if [ "${1/./}" == "${1}" ] ; then
    # "float" has no decimal point so set fraction to "0".
    fraction="0"
  else
    # Set fraction to the digits to the right of the decimal point.
    fraction=${1##*.}
    # Remove leading zeroes so it is not interpreted as octal.  Also, add a trailing zero so we don't wind up with a blank value.
    shopt -s extglob
    fraction=${fraction##+(0)}0
  fi

  #print_var_list "whole fraction"

  if (( ${#1} == 0 )) || ! printf "%i %i" "${whole}" "${fraction}" >/dev/null 2>&1 ; then
    { print_error ; echo "Parameter \"float\" has an invalid value of \"${1}\".  The caller must provide a floating point value." ; } | process_error_message
    return 1
  fi

  # If the fractional part of the original number is non-zero, we increment the "whole" portion of the number.
  (( ${fraction} != 0 )) && [ ! -z "${fraction}" ] && let whole++

  [ -z "${2}" ] && echo ${whole} || eval ${2}=${whole}

}
################################################################################



################################################################################
function absolute_dir_path {
  local dir_path_name="${1}" ; shift || :
  local quiet="${1:-1}" ; shift || :

  # This function will expand the directory path (i.e. change it from relative to absolute).

  local save_pwd=${PWD}

  if [ -d "${!dir_path_name}" ] ; then
    cd ${!dir_path_name}
    eval ${dir_path_name}=${PWD}/
  else
    local list_element
    local loc_dir_path=${!dir_path_name}
    local new_dir_path
    while retrieve_list_element list_element loc_dir_path "front" "/" 1 1 2>/dev/null ; do
      cmd_fnc_u "cd ${list_element}" 2>/dev/null
      if [ "${?}" == "0" ] ; then
        new_dir_path=${PWD}/${loc_dir_path}
      fi
    done
    eval ${dir_path_name}=${new_dir_path}
  fi

  cd ${save_pwd}

}
################################################################################



# file_var_suffixes is for use by programs as well as by functions in this file such as get_file_attributes.  We guarantee no specific order of the suffixes contained in it.
if ! test "${file_var_suffixes+defined}" ; then
  readonly file_var_suffixes='name quoted_name size num_blocks block_size io_block_size raw_mode_hex type device_num device_num_hex inode_num num_links access access_octal uname uid gname gid access_time access_seconds modify_time modify_seconds change_time change_seconds selinux_security major_dev_type minor_dev_type'
fi
################################################################################
function get_file_attributes {
  local file_var_prefix="${1}" ; shift
  local file_path="${1}" ; shift

  # This function will obtain all the file attributes provided by the stat command and assign the values to variables which all begin with ${file_var_prefix}.

  # Example use:
  # get_file_attributes "${my_file}" my_file
  # print_var my_file_size

  valid_value file_var_prefix || return 1
  valid_file_path file_path || return 1

  local cmd_buf
  local temp_misc_file
  create_temp_file_name temp_misc_file "" 0

  cmd_buf='stat --printf "%n\n%N\n%s\n%b\n%B\n%o\n%f\n%F\n%d\n%D\n%i\n%h\n%A\n%a\n%U\n%u\n%G\n%g\n%x\n%X\n%y\n%Y\n%z\n%Z\n%C\n%t\n%T\n" ${file_path} > ${temp_misc_file}'
  #issuing
  eval ${cmd_buf}

  local IFS=$' \t\n'
  local suffix
  for suffix in ${file_var_suffixes} ; do
    eval read ${file_var_prefix}_${suffix}
  done < ${temp_misc_file}

  rm -f ${temp_misc_file}

}
################################################################################



################################################################################
function print_file_attributes {
  local file_var_prefix="${1}" ; shift
  local file_path="${1}" ; shift
  local loc_file_var_suffixes="${1:-${file_var_suffixes}}" ; shift

  # This function will print the file attribute values associated with the file_var_prefix value.  If the caller includes a file_path value, then this function will first call get_file_attributes to obtain the attributes.
  # file_var_prefix             A variable prefix for variables associated with a given file.
  # loc_file_var_suffixes       A list of suffixes for the variables you wish to have printed.  The default is to print all variables represented by the contents of global variable file_var_suffixes.

  if [ ! -z "${file_path}" ] ; then
    get_file_attributes ${file_path} ${file_var_prefix} || return 1
  else
    valid_value file_var_prefix || return 1
  fi

  local suffix
  local IFS=$' \t\n'
  for suffix in ${loc_file_var_suffixes} ; do
    print_var ${file_var_prefix}_${suffix}
  done

}
################################################################################



# Perf data:
# #(CST) 2014/02/10 14:17:22.575234 -    0.008290 - Issuing: for (( ix=0 ; ix < 100 ; ix++ )) ; do filepath_to_varname /afs/rchland.ibm.com/usr8/csptest/lock_test/file1 obj_name ; done
# total_seconds:                                    0.054165000
# seconds_each:                                     0.000541650
# count_per_second:                                 1846
################################################################################
function filepath_to_varname {
  # local filepath="${1}"
  # local varname="${2}"

  # This function will take a filepath and convert it to a legal variable name.  To accomplish this, all non alpha-numeric characters are converted to underscores.

  if (( ${#1} == 0 )) ; then
    { print_error "Parameter \"filepath\" has an invalid value of \"${1}\"." ; echo ; } | process_error_message
    return 1
  fi

  if (( ${#2} == 0 )) ; then
    { print_error "Parameter \"varname\" has an invalid value of \"${2}\"." ; echo ; } | process_error_message
    return 1
  fi

  local cmd_buf

  #cmd_buf="${varname}='${filepath//[^A-Za-z0-9]/_}'"
  cmd_buf="${2}='${1//[^A-Za-z0-9]/_}'"
  #issuing
  eval ${cmd_buf}

}
################################################################################



# Perf data:
# With get_abs_dir_path=0...
# total_seconds:                                    0.323067000
# seconds_each:                                     0.000323067
# count_per_second:                                 3095


# With get_abs_dir_path=1...
# total_seconds:                                    0.577345000
# seconds_each:                                     0.000577345
# count_per_second:                                 1732

################################################################################
function split_path {
  # local file_path="${1}"
  # local dir_path_var="${2}"
  # local base_name_var="${3}"
  # local get_abs_dir_path="${4:-0}"

  # This function will split the file_path into its directory and base name components.  It is about 20 times faster than using "dir_path=$(dirname ${file_path} ; base_name=$(basename ${file_path}."
  # If dir_path_var is null, no dir path is returned.
  # If base_name_var is null, no base name is returned.
  # get_abs_dir_path indicates that you wish to have the absolute dir_path returned.

  if [ ! -z "${2}" ] ; then
    # dir_path_var was specified.
    eval ${2}=${1%/*}/
    # If no dirname is included in file_path, we assign "./".
    [ "${!2}" == "${1}" ] && eval ${2}="./"
    if (( ${4} )) ; then
      local saved_pwd=${PWD}
      cd ${!2} 2>/dev/null && { eval ${2}=${PWD}/ ; cd ${saved_pwd}; }
    else
      add_trailing_char ${2}
    fi
  fi
  if [ ! -z "${3}" ] ; then
    # base_name_var was specified.
    eval ${3}=${1##*/}
  fi

}
################################################################################



################################################################################
function get_real_caller_func {
  local funcname_var="${1}" ; shift

  # Determine the caller's "real" funcname, i.e. if the caller's name is cmd_fnc or cmd_fnc_u, we will continue up the call stack to get the "real" funcname.
  # This means that the caller of the function calling us can be cmd_fnc.  However, don't call THIS function with cmd_fnc.

  local ix

  for ((ix=2; ix<${#FUNCNAME[@]}; ix++)) ; do
    eval ${funcname_var}=${FUNCNAME[${ix}]:-main}
    [ "${!funcname_var:0:7}" != "cmd_fnc" -a "${!funcname_var}" != "my_time" ] && break
  done

}
################################################################################



################################################################################
function check_pts_group_membership {
  local group_name="${1}" ; shift
  local group_cell="${1:-$(afs_cell)}" ; shift
  local userid="${1:-${USER}}" ; shift
  local print_err="${1:-1}" ; shift

  # This function will check to see whether "userid" is a member of the pts group named in "group_name".  It returns 0 if it is a member and 1 otherwise.

  # group_name	The name of the pts group to be checked.
  # userid	The id to search vor.
  # print_err	Indicates whether an error is to be printed to stderr if the userid is NOT a member of the group.

  local rc
  local cmd_buf

  cmd_buf="pts membership ${group_name} -cell ${group_cell} | egrep -q '^[ ]*${userid}[ ]*$'"
  #issuing
  eval ${cmd_buf}
  rc="${?}"
  if [ "${rc}" != "0" ] && (( print_err )) ; then
    { print_error ; echo "Userid \"${userid}\" is not a member of acl group \"${group_name}\"." ; } | process_error_message
  fi

  return ${rc}

}
################################################################################



################################################################################
function print_stars {

  if (( ! quiet )) ; then
    echo '********************************************************************************'
  fi

}
################################################################################



################################################################################
function change_to_varname {

  #local var_name="${1}"
  #local lower_case="${2:-1}"

  # This function will change the value in var_name to be a valid bash variable name.
  # Example:
  # var1="Panel power on, norm (upd)"
  # change_to_varname var1
  # The result:
  # var1 is now "panel_power_on_norm_upd" which is a valid bash variable name.

  # In general, non alpha numerics are changed to underscores except for the following chars which are simply eliminated:
  # Grouping characters: Parenthesis (e.g. "(" and ")", square braces, curly braces.
  # Commas followed by a space.
  # "#" characters.
  #
  # Also, if the first char is numeric, an underscore will be pre-pended.

  case ${#@} in
    0)
      { print_error "Programmer error - Parameter \"var_name\" has an invalid value of \"${1}\".  It must contain a valid variable name." ; echo ; } | process_error_message
      return 1
    ;;
  esac

  if (( ${2:-1} )) ; then
    change_case ${1} 0 || return 1
  fi

  local buffer="${!1}"

  case "${!1:0:1}" in [0-9])
    # First char is numeric so we'll pre-pend an underscore.
    buffer="_${buffer}"
    ;;
  esac

  # Change ", " to " ", i.e. eliminate commas followed by space.
  buffer=${buffer//, / }

  # Eliminate grouping chars.
  buffer=${buffer//[()\{\}\[\]#]/}

  # Change all other non-alphanums to underscores.
  shopt -s extglob

  buffer=${buffer//[^a-zA-Z0-9]/_}

  eval ${1}=${buffer}


}
################################################################################



# For 3 element array...
# #(CDT) 2015/05/14 17:59:50 - Issuing: for (( ix=0 ; ix < 1001 ; ix++ )) ; do reverse_array arr1 ; done
# total_seconds:               0.287591000
# seconds_each:                0.000287303
# count_per_second:            3481
# For 57 element array...
# #(CDT) 2015/05/14 18:01:32 - Issuing: for (( ix=0 ; ix < 1001 ; ix++ )) ; do reverse_array arr1 ; done
# total_seconds:               1.905548000
# seconds_each:                0.001903644
# count_per_second:            525
################################################################################
function reverse_array {
  # local buffer_arr_var="${1}"

  # This function will take the array passed in buffer_arr_var and reverse all of its elements.

  case "${buffer_arr_var}" in "")
    local buffer_arr_var="${1}"
    valid_value buffer_arr_var || return 1
  esac

  local _ra_temp_arr_
  local _ra_array_size_
  local temp
  local cmd_buf

  # Get array size.
  eval "_ra_array_size_=\${#${1}[@]}"

  # Walk backward through original array and assign each element to _ra_temp_arr_.
  local ix
  let ix=_ra_array_size_-1
  for (( ; ix >= 0; ix-- )) ; do
    # Perf: We can avoid the use of eval by using an intermediate variable.  However, this file needs to work on bash 2.x (e.g. on systems like w3dev.rchland.ibm.com).
    #temp=${1}[${ix}]
    #_ra_temp_arr_+=("${!temp}")
    cmd_buf="_ra_temp_arr_+=(\"\${${1}[${ix}]}\")"
    #issuing
    eval ${cmd_buf}
  done

  # Copy the temp array back to the caller's array variable.
  eval "${1}=(\"\${_ra_temp_arr_[@]}\")"

}
################################################################################




################################################################################
function my_printenv {

  # This function will print all environment variables, sorted by name with a header and footer.

  echo
  print_dashes
  echo "Environment variables, sorted by name:"
  echo
  echo
  printenv | sort
  print_dashes
  echo

}
################################################################################
