#!/usr/bin/env python3
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: op-test-framework/testcases/PowerNVDump.py $
#
# OpenPOWER Automated Test Project
#
# Contributors Listed Below - COPYRIGHT 2018-2019
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

#  @package PowerNVDump.py
#  This module can contain testcases related to Firmware & Kernel dump feature
#  including kdump, fadump aka MPIPL, opaldump, etc.
#
#   fadump aka MPIPL:
#   The goal of firmware-assisted dump is to enable the dump of
#   a crashed system, and to do so from a fully-reset system.
#   For more details refer
#       https://www.kernel.org/doc/Documentation/powerpc/firmware-assisted-dump.txt
#
#   kdump:
#   Kdump uses kexec to quickly boot to a dump-capture kernel whenever a
#   dump of the system kernel's memory needs to be taken (for example, when
#   the system panics).
#   For more details refer
#       https://www.kernel.org/doc/Documentation/kdump/kdump.txt
#
#   opaldump:
#   With MPIPL we support capturing opalcore. We can use gdb to debug OPAL
#   issues. For details refer `doc/mpipl.rst` under skiboot source tree.
#
#   Test scenarios:
#   1. Verify SBE initiated MPIPL flow (trigger SBE S0 interrupt directly)
#   2. Verify OPAL crash (trigger OPAL assert via pdbg)
#   3. Enable fadump - trigger a kernel crash
#   4. Enable kdump  - trigger a kernel crash
#   5. Disable dump  - trigger a kernel crash
#
#      and verify boot progress and collected dump components
#      (vmcore and opalcore).
#

import os
import pexpect
import unittest
import time

import OpTestConfiguration
from common import OpTestInstallUtil
from common.OpTestSystem import OpSystemState
from common.Exceptions import KernelOOPS, KernelPanic, KernelCrashUnknown, KernelKdump, KernelFADUMP, PlatformError, CommandFailed, SkibootAssert
from common.OpTestConstants import OpTestConstants as BMC_CONST
from common.OpTestError import OpTestError


class BootType():
    NORMAL = 1
    MPIPL = 2
    KDUMPKERNEL = 3
    INVALID = 4


class PowerNVDump(unittest.TestCase):

    def setUp(self):
        conf = OpTestConfiguration.conf
        self.cv_SYSTEM = conf.system()
        self.cv_HOST = conf.host()
        self.cv_BMC = conf.bmc()
        self.bmc_type = conf.args.bmc_type
        self.util = self.cv_SYSTEM.util
        self.pdbg = conf.args.pdbg
        self.basedir = conf.basedir
        self.c = self.cv_SYSTEM.console
        if self.bmc_type == "FSP_PHYP":
            self.is_lpar = True
            self.hmc_user = conf.args.hmc_username
            self.hmc_password = conf.args.hmc_password
            self.hmc_ip = conf.args.hmc_ip
            self.lpar_name = conf.args.lpar_name
            self.system_name = conf.args.system_name
            self.cv_HMC = self.cv_SYSTEM.hmc
        self.server_ip = conf.args.server_ip
        self.server_pw = conf.args.server_pw
        self.net_path = conf.args.net_path
        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        res = self.c.run_command("cat /etc/os-release")
        if "Ubuntu" in res[0] or "Ubuntu" in res[1]:
            self.distro = "ubuntu"
        elif 'Red Hat' in res[0] or 'Red Hat' in res[1]:
            self.distro = 'rhel'
        elif 'SLES' in res[0] or 'SLES' in res[1]:
            self.distro = 'sles'
        else:
            raise self.skipTest("Test currently supported only on ubuntu, sles and rhel")

    def setup_test(self, dump_place="local"):
        # crash_content : a variable to point to right crash folder after core is
        # generated by mpipl/kdump kernel. If dump failed this variable would be
        # empty.
        if dump_place == "local":
            self.crash_content = self.c.run_command(
                "ls -l /var/crash | grep '^d'| awk '{print $9}'")
        if dump_place == "net":
            self.crash_content = self.c.run_command(
                "ssh root@%s \"ls -l /var/crash | grep '^d'\" | awk '{print $9}'" % self.server_ip)

    # Verify fadump command line parameter
    def is_fadump_param_enabled(self):
        res = self.cv_HOST.host_run_command(BMC_CONST.PROC_CMDLINE)
        if "fadump=on" in " ".join(res):
            return True
        return False

    def is_fadump_enabled(self):
        res = self.c.run_command("cat /sys/kernel/fadump_enabled")[-1]
        if int(res) == 1:
            return True
        elif int(res) == 0:
            return False
        else:
            raise Exception("Unknown fadump_enabled value")

    def is_fadump_supported(self):
        try:
            self.c.run_command("ls /sys/kernel/fadump_enabled")
            return True
        except CommandFailed:
            return False

    # Verify /ibm,opal/dump node is present int DT or not
    def is_mpipl_supported(self):
        try:
            self.c.run_command("ls %s" % BMC_CONST.OPAL_DUMP_NODE)
            return True
        except CommandFailed:
            return False

    def is_mpipl_boot(self):
        try:
            self.c.run_command("ls %s/mpipl-boot 2>/dev/null" % BMC_CONST.OPAL_DUMP_NODE)
            return True
        except CommandFailed:
            return False

    def verify_dump_dt_node(self, boot_type=BootType.NORMAL):
        self.c.run_command("lsprop  %s" % BMC_CONST.OPAL_DUMP_NODE)
        self.c.run_command("lsprop %s/fw-load-area" % BMC_CONST.OPAL_DUMP_NODE)
        if boot_type == BootType.MPIPL:
            self.c.run_command("lsprop %s/mpipl-boot" % BMC_CONST.OPAL_DUMP_NODE)

    def verify_dump_file(self, boot_type=BootType.NORMAL, dump_place="local"):
        if dump_place == "local":
            crash_content_after = self.c.run_command(
                "ls -l /var/crash | grep '^d'| awk '{print $9}'")
        if dump_place == "net":
            crash_content_after = self.c.run_command(
                "ssh root@%s \"ls -l /var/crash | grep '^d'\" | awk '{print $9}'" % self.server_ip)
        self.crash_content = list(
            set(crash_content_after) - set(self.crash_content))
        if len(self.crash_content):
            if dump_place == "net":
                self.c.run_command('scp -r root@%s://var/crash/%s /var/crash/' %
                                  (self.server_ip, self.crash_content[0]), timeout=600)
            if self.distro == "ubuntu":
                self.c.run_command("ls /var/crash/%s/dump*" %
                                   self.crash_content[0])
            else:
                self.c.run_command("ls /var/crash/%s/vmcore*" %
                                   self.crash_content[0])
            if boot_type == BootType.MPIPL:
                self.c.run_command("ls /var/crash/%s/opalcore*" %
                                   self.crash_content[0])
        else:
            msg = "Dump directory not created"
            raise OpTestError(msg)
        self.c.run_command("rm -rf /var/crash/%s; sync" % self.crash_content[0])

    def verify_fadump_reg(self):
        res = self.c.run_command("cat /sys/kernel/fadump_registered")[-1]
        if int(res) == 1:
            self.c.run_command("echo 0 > /sys/kernel/fadump_registered")

        if not self.is_lpar:
            self.c.run_command("dmesg > /tmp/dmesg_log")
            self.c.run_command("%s > /tmp/opal_log" % BMC_CONST.OPAL_MSG_LOG)
        self.c.run_command("echo 1 > /sys/kernel/fadump_registered")

        # Verify OPAL msglog to confirm whether registration passed or not
        if not self.is_lpar:
            opal_data = " ".join(self.c.run_command(
                "%s | diff -a /tmp/opal_log -" % BMC_CONST.OPAL_MSG_LOG))
            if "DUMP: Payload registered for MPIPL" in opal_data:
                print("OPAL: Payload registered successfully for MPIPL")
            else:
                raise OpTestError("OPAL: Payload failed to register for MPIPL")

            # Verify kernel dmesg
            dmesg_data = " ".join(self.c.run_command(
                "dmesg | diff -a /tmp/dmesg_log -"))
            if "fadump: Registering for firmware-assisted kernel dump" in dmesg_data:
                print("PowerNV: Registering for firmware-assisted kernel dump")
            else:
                raise OpTestError("PowerNV: Registering for firmware-assisted kernel dump failed")

            self.c.run_command("rm /tmp/opal_log")
            self.c.run_command("rm /tmp/dmesg_log")

    def verify_fadump_unreg(self):
        res = self.c.run_command("cat /sys/kernel/fadump_registered")[-1]
        if int(res) == 0:
            self.c.run_command("echo 1 > /sys/kernel/fadump_registered")

        if not self.is_lpar:
            self.c.run_command("%s > /tmp/opal_log" % BMC_CONST.OPAL_MSG_LOG)
            self.c.run_command("dmesg > /tmp/dmesg_log")
            self.c.run_command("echo 0 > /sys/kernel/fadump_registered")

            opal_data = " ".join(self.c.run_command(
                "%s | diff -a /tmp/opal_log -" % BMC_CONST.OPAL_MSG_LOG))
            if "DUMP: Payload unregistered for MPIPL" in opal_data:
                print("OPAL: Payload unregistered for MPIPL")
            else:
                raise OpTestError("OPAL: Payload failed to unregister for MPIPL")

            dmesg_data = " ".join(self.c.run_command(
                "dmesg | diff -a /tmp/dmesg_log -"))
            if "fadump: Un-register firmware-assisted dump" in dmesg_data:
                print("PowerNV: Un-registering for firmware-assisted kernel dump")
            else:
                raise OpTestError("PowerNV: Un-registering for firmware-assisted kernel dump failed")

            self.c.run_command("rm /tmp/opal_log")
            self.c.run_command("rm /tmp/dmesg_log")

    ##
    # @brief This function will test the kernel crash followed by system
    #        reboot. It has below steps
    #        1. Enable reboot on kernel panic: echo 10 > /proc/sys/kernel/panic
    #        2. Trigger kernel crash: echo c > /proc/sysrq-trigger
    #
    # @return BMC_CONST.FW_SUCCESS or raise OpTestError
    #
    def kernel_crash(self, crash_type="echo_c"):
        self.c.run_command("uname -a")
        self.c.run_command("cat /etc/os-release")
        # Disable fast-reboot, otherwise MPIPL may lead to fast-reboot
        if not self.is_lpar:
            self.c.run_command("nvram -p ibm,skiboot --update-config fast-reset=0")
        self.c.run_command("echo 10 > /proc/sys/kernel/panic")
        # Enable sysrq before triggering the kernel crash
        self.c.pty.sendline("echo 1 > /proc/sys/kernel/sysrq")
        if crash_type == "echo_c":
            self.c.pty.sendline("echo c > /proc/sysrq-trigger")
        elif crash_type == "hmc":
            self.cv_HMC.run_command("chsysstate -r lpar -m %s -n %s -o dumprestart" %
                                   (self.system_name, self.lpar_name))
        done = False
        boot_type = BootType.NORMAL
        rc = -1
        while not done:
            try:
                # MPIPL completion + system reboot would take time, keeping it
                # 600 seconds. Post MPIPL, kernel will offload vmcore and reboot
                # system. Hostboot will run istep 10.1 in normal boot only. So
                # check for istep 10.1 to detect normal boot.
                rc = self.c.pty.expect(
                    ["ISTEP 10. 1", "saving vmcore complete", "saved vmcore", "Rebooting."], timeout=600)
            except KernelFADUMP:
                print("====================MPIPL boot started==================")
                # if fadump is enabled system should start MPIPL after kernel crash
                self.cv_SYSTEM.set_state(OpSystemState.IPLing)
                boot_type = BootType.MPIPL
            except KernelOOPS:
                print("==================Normal Boot===========================")
                # if both fadump and kdump is disabled, system should do normal
                # IPL after kernel crash(oops)
            except KernelPanic:
                print("==================Normal Boot===========================")
                # if both fadump and kdump is disabled, system should do
                # normal IPL after kernel crash(oops)
                boot_type = BootType.NORMAL
            except KernelKdump:
                print("================Kdump kernel boot=======================")
                # if kdump is enabled, kdump kernel should boot after kernel crash
                boot_type = BootType.KDUMPKERNEL
            except KernelCrashUnknown:
                self.cv_SYSTEM.set_state(OpSystemState.UNKNOWN_BAD)
                done = True
                boot_type = BootType.NORMAL
            except pexpect.TIMEOUT:
                done = True
                boot_type = BootType.INVALID
                self.cv_SYSTEM.set_state(OpSystemState.UNKNOWN_BAD)
            except PlatformError:
                done = True
                boot_type = BootType.NORMAL
            if rc == 0:
                self.cv_SYSTEM.set_state(OpSystemState.IPLing)
                done = True
            if rc == 1 or rc == 2 or rc == 3:
                print("Kdump finished collecting core file, waiting for regular IPL to complete")
                if self.is_lpar:
                    print("Kdump finished collecting core file, waiting for LPAR to boot")
                    self.cv_SYSTEM.set_state(OpSystemState.UNKNOWN)
                    done = True

        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        print("System booted fine to host OS...")
        return boot_type


class OPALCrash_MPIPL(PowerNVDump):
    '''
    OPAL initiated MPIPL flow validation. This will verify whether OPAL
    supports MPIPL or not and then triggers OPAL assert. This will verify
    OPAL MPIPL flow and device tree property after dump. It will not
    verify whether core file is generated or not.
    '''
    def runTest(self):
        if not self.pdbg or not os.path.exists(self.pdbg):
            self.fail("pdbg file %s doesn't exist" % self.pdbg)

        self.setup_test()

        if not self.is_mpipl_supported():
            raise self.skipTest("MPIPL support is not found")

        # Verify device tree properties
        self.verify_dump_dt_node()

        pdbg_cmd = ""
        if "OpenBMC" in self.bmc_type:
            pdbg_cmd = "/tmp/pdbg -a putmem 0x300000f8 < /tmp/deadbeef"
        elif "SMC" in self.bmc_type:
            pdbg_cmd = "/tmp/rsync_file/pdbg -a putmem 0x300000f8 < /tmp/rsync_file/deadbeef"
        else:
            raise self.skipTest("pdbg not support on this BMC type : %s" % self.bmc_type)

        # To Verify OPAL MPIPL flow we don't need host kdump service.
        # Hence disable kdump service
        os_level = self.cv_HOST.host_get_OS_Level()
        if self.cv_HOST.host_check_pkg_kdump(os_level) is True:
            self.cv_HOST.host_disable_kdump_service(os_level)

        cmd = "rm /tmp/pdbg; rm /tmp/deadbeef"
        try:
            self.cv_BMC.run_command(cmd)
        except CommandFailed:
            pass
        # copy the pdbg file to BMC
        self.cv_BMC.image_transfer(self.pdbg)
        deadbeef = os.path.join(self.basedir, "test_binaries", "deadbeef")
        self.cv_BMC.image_transfer(deadbeef)
        # Trigger OPAL assert via pdbg
        self.cv_BMC.run_command(pdbg_cmd)

        done = False
        boot_type = BootType.NORMAL
        rc = -1
        while not done:
            try:
                # MPIPL boot will take time, keeping it 600 seconds.
                rc = self.c.pty.expect(['\n', 'ISTEP 14. 8'], timeout=600)
            except(SkibootAssert, KernelFADUMP):
                print("====================MPIPL boot started===================")
                # System will start MPIPL flow after OPAL assert
                self.cv_SYSTEM.set_state(OpSystemState.IPLing)
                boot_type = BootType.MPIPL
            except pexpect.TIMEOUT:
                done = True
                boot_type = BootType.INVALID
                self.cv_SYSTEM.set_state(OpSystemState.UNKNOWN_BAD)
            except PlatformError:
                done = True
                boot_type = BootType.NORMAL
            if rc == 1:
                self.cv_SYSTEM.set_state(OpSystemState.IPLing)
                done = True

        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        print("System booted fine to host OS...")
        if not self.is_mpipl_boot():
            raise OpTestError("OPAL: MPIPL boot failed")
        self.verify_dump_dt_node(BootType.MPIPL)
        return boot_type


class SBECrash_MPIPL(PowerNVDump):
    '''
    Testcase to test SBE and hostboot part of MPIPL code.
    This test would trigger SBE S0 interrupt directly to initiate MPIPL.
    SBE will initiate MPIPL flow and eventually system boots back.
    '''

    def runTest(self):

        if "OpenBMC" not in self.bmc_type:
            raise self.skipTest(
                "SBE initiated MPIPL is not supported on non-OpenBMC machine yet")

        self.setup_test()

        self.c.run_command("uname -a")
        self.c.run_command("cat /etc/os-release")
        # Get all chip ids on the machine
        xscom_dirs = self.c.run_command(
            "ls /sys/firmware/devicetree/base/ | grep xscom")
        secondary_chip_ids = []
        primary_chipid = None
        for node in xscom_dirs:
            if node:
                chip_id = self.c.run_command(
                    "lsprop /sys/firmware/devicetree/base/%s/ibm,chip-id" % node)
                # Check if chip_id is primary. For some reason os.path.exists is
                # failing. Hence using `ls` command to detect primary property
                try:
                    self.c.run_command("ls /sys/firmware/devicetree/base/%s/primary 2>/dev/null" % node)
                    primary_chipid = chip_id[-1].strip()
                except CommandFailed:
                    secondary_chip_ids.append(chip_id[-1].strip())
                    pass

        if not primary_chipid:
            raise OpTestError("BUG: Primary node property is missing!!")

        # To Verify SBE/hostboot MPIPL flow we don't need host kdump service.
        # Hence disable kdump service
        os_level = self.cv_HOST.host_get_OS_Level()
        if self.cv_HOST.host_check_pkg_kdump(os_level) is True:
            self.cv_HOST.host_disable_kdump_service(os_level)

        # Make sure /tmp/skiboot directory does not exist
        r_workdir = "/tmp/skiboot"
        self.c.run_command("rm -rf %s" % r_workdir)

        # Clone skiboot git repository
        r_cmd = "git clone --depth 1 https://github.com/open-power/skiboot.git %s" % r_workdir
        self.c.run_command(r_cmd)
        # Compile putscom utility
        r_cmd = "cd %s/external/xscom-utils; make; cd -" % r_workdir
        self.c.run_command(r_cmd)
        try:
            # Check existence of putscom utility after compiling
            r_cmd = "test -f %s/external/xscom-utils/putscom" % r_workdir
            self.c.run_command(r_cmd)
        except CommandFailed as cf:
            raise self.skipTest(
                "putscom utility missing after compiling!!! %s" % str(cf))
        # BMC is not aware of MPIPL. We have to reset MBOX so that it can point
        # to initial flash area and SBE can load it from LPC bus.
        cmd = "mboxctl --reset"
        self.cv_BMC.run_command(cmd)
        # trigger SBE initiated MPIPL starting with secondary chip ids followed
        # by primary chip (Send S0 interrupt to SBE).
        if secondary_chip_ids:
            for chip_id in secondary_chip_ids:
                self.c.pty.sendline(
                    "%s/external/xscom-utils/putscom -c %s 0x50008 0x0002000000000000" % (r_workdir, chip_id))
        self.c.pty.sendline(
            "%s/external/xscom-utils/putscom -c %s 0x50008 0x0002000000000000" % (r_workdir, primary_chipid))

        done = False
        boot_type = BootType.NORMAL
        rc = -1
        while not done:
            try:
                # Verify MPIPL boot (wait for 600 secs before throwing error)
                rc = self.c.pty.expect(['ISTEP 14. 8'], timeout=600)
            except pexpect.TIMEOUT:
                done = True
                boot_type = BootType.INVALID
                self.cv_SYSTEM.set_state(OpSystemState.UNKNOWN_BAD)
            except PlatformError:
                done = True
                boot_type = BootType.NORMAL
            if rc == 0:
                print("===================MPIPL boot started===================")
                self.cv_SYSTEM.set_state(OpSystemState.IPLing)
                boot_type = BootType.MPIPL
                done = True

        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        print("System booted fine to host OS...")
        print("cleanup skiboot clone")
        r_cmd = "rm -rf %s" % r_workdir
        self.c.run_command(r_cmd)


class KernelCrash_FadumpEnable(PowerNVDump):

    def setup_fadump(self):
        self.cv_SYSTEM.set_state(OpSystemState.OS)
        if self.distro == "rhel":
            self.c.run_command("sed -e '/nfs/ s/^#*/#/' -i /etc/kdump.conf; sync")
            self.c.run_command("sed -i 's/path \//path \/var\/crash/' /etc/kdump.conf; sync")
            obj = OpTestInstallUtil.InstallUtil()
            if not obj.update_kernel_cmdline(self.distro, args="fadump=on crashkernel=2G-128G:2048M,128G-:8192M",
                                             reboot=True, reboot_cmd=True):
                self.fail("KernelArgTest failed to update kernel args")
        if self.distro == "sles":
            self.c.run_command('sed -i \'/^KDUMP_SAVEDIR=/c\KDUMP_SAVEDIR=\"/var/crash\"\' /etc/sysconfig/kdump;')
            self.c.run_command("sed -i '/KDUMP_FADUMP=\"no\"/c\KDUMP_FADUMP=\"yes\"' /etc/sysconfig/kdump")
            self.c.run_command("touch /etc/sysconfig/kdump; systemctl restart kdump.service; sync", timeout=600)
            self.c.run_command("mkdumprd -f", timeout=600)
            self.c.run_command("update-bootloader --refresh")
            self.c.run_command("zypper install -y ServiceReport; servicereport -r; echo $?", timeout=600)
            time.sleep(5)
        self.cv_SYSTEM.goto_state(OpSystemState.OFF)
        self.cv_SYSTEM.goto_state(OpSystemState.OS)

    def runTest(self):
        self.setup_test()
        self.setup_fadump()
        self.c.run_command("fsfreeze -f /boot; fsfreeze -u /boot", timeout=600)
        if not self.is_lpar:
            if not self.is_mpipl_supported():
                raise self.skipTest("MPIPL support is not found")
            self.verify_dump_dt_node()
        if not self.is_fadump_param_enabled():
            raise self.skipTest(
                "fadump=on not added in kernel param, please add and re-try")
        if not self.is_fadump_supported():
            raise self.skipTest(
                "fadump not enabled in the kernel, does system has right firmware!!!")
        if not self.is_fadump_enabled():
            raise self.skipTest("fadump_enabled is off")
        if self.distro == "ubuntu":
            self.cv_HOST.host_check_command("kdump")
        elif self.distro == "rhel":
            self.cv_HOST.host_check_command("kdumpctl")
        os_level = self.cv_HOST.host_get_OS_Level()
        self.verify_fadump_unreg()
        self.verify_fadump_reg()
        self.cv_HOST.host_run_command("stty cols 300;stty rows 30")
        self.cv_HOST.host_enable_kdump_service(os_level)
        print("======================fadump is supported=======================")
        boot_type = self.kernel_crash()
        if not self.is_lpar:
            self.verify_dump_dt_node(boot_type)
        self.verify_dump_file(boot_type)


class KernelCrash_OnlyKdumpEnable(PowerNVDump):

    def runTest(self):
        self.setup_test()
        if not self.is_lpar:
            if self.is_fadump_supported():
                raise self.skipTest("fadump is enabled, please disable(remove fadump=on \
                                   kernel parameter and re-try")
        if self.is_fadump_param_enabled():
            raise self.skipTest(
                "fadump=on added in kernel param, please remove and re-try")
        if self.distro == "ubuntu":
            self.cv_HOST.host_check_command("kdump")
        elif self.distro == "rhel":
            self.cv_HOST.host_check_command("kdumpctl")
        os_level = self.cv_HOST.host_get_OS_Level()
        self.cv_HOST.host_run_command("stty cols 300;stty rows 30")
        self.cv_HOST.host_enable_kdump_service(os_level)
        boot_type = self.kernel_crash()
        self.verify_dump_file(boot_type)
        if self.is_lpar:
            boot_type = self.kernel_crash(crash_type="hmc")
            self.verify_dump_file(boot_type)


class KernelCrash_DisableAll(PowerNVDump):

    def runTest(self):
        self.setup_test()
        if self.is_fadump_param_enabled():
            raise self.skipTest(
                "fadump=on added in kernel param, please remove and re-try")
        if self.distro == "ubuntu":
            self.cv_HOST.host_check_command("kdump")
        elif self.distro == "rhel":
            self.cv_HOST.host_check_command("kdumpctl")
        os_level = self.cv_HOST.host_get_OS_Level()
        self.cv_HOST.host_run_command("stty cols 300;stty rows 30")
        self.cv_HOST.host_disable_kdump_service(os_level)
        boot_type = self.kernel_crash()
        if boot_type != BootType.NORMAL:
            msg = "Invalid boot %d after kernel crash instead of normal boot" % int(
                boot_type)
            raise OpTestError(msg)


class SkirootKernelCrash(PowerNVDump, unittest.TestCase):

    def setup_test(self):
        self.cv_SYSTEM.goto_state(OpSystemState.PETITBOOT_SHELL)
        output = self.c.run_command(BMC_CONST.PROC_CMDLINE)
        res = ""
        update = False
        for pair in output[0].split(" "):
            if "xmon" in pair:
                if pair == "xmon=off":
                    return
                pair = "xmon=off"
                update = True
            res = "%s %s" % (res, pair)

        if not update:
            pair = "xmon=off"
            res = "%s %s" % (res, pair)
        bootargs = "\'%s\'" % res
        print(bootargs)
        self.c.run_command(
            "nvram -p ibm,skiboot --update-config bootargs=%s" % bootargs)
        self.cv_SYSTEM.goto_state(OpSystemState.OFF)
        self.cv_SYSTEM.goto_state(OpSystemState.PETITBOOT_SHELL)

    ##
    # @brief This tests the Skiroot kernel crash followed by system IPL
    #        1. Skiroot kernel has by default xmon is on, so made it off
    #        2. Trigger kernel crash: echo c > /proc/sysrq-trigger
    #        3. Check for system booting
    #
    # @return BMC_CONST.FW_SUCCESS or raise OpTestError
    #
    def runTest(self):
        self.setup_test()
        self.cv_SYSTEM.sys_set_bootdev_no_override()
        self.kernel_crash()

class KernelCrash_KdumpNetwork(PowerNVDump):

    def setup_ssh(self):
        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        if self.distro == "rhel":
            self.c.run_command("sed -i '/ssh user@my.server.com/c\ssh root@%s' /etc/kdump.conf; sync" % self.server_ip)
            self.c.run_command("sed -i '/sshkey \/root\/.ssh\/kdump_id_rsa/c\sshkey \/root\/.ssh\/id_rsa' /etc/kdump.conf; sync")
            self.c.run_command("sed -i 's/-l --message-level/-l -F --message-level/' /etc/kdump.conf; sync")
            self.c.run_command("sed -i '/path \/var\/crash/c\path %s' /etc/kdump.conf; sync" % self.net_path)
            self.c.run_command("cd /root; kdumpctl propagate", timeout=600)
            self.c.run_command("kdumpctl restart", timeout=600)
            self.c.run_command("fsfreeze -f /boot; fsfreeze -u /boot", timeout=600)
            time.sleep(5)
            res = self.c.run_command("service kdump status | grep active")
            if 'dead' in res:
                self.fail("Kdump service is not configured properly")
        elif self.distro == "ubuntu":
            self.c.run_command("sed -i '/SSH=\"<user at server>\"/c\SSH=\"root@%s\"' /etc/default/kdump-tools" % self.server_ip)
            self.c.run_command("sed -i '/SSH_KEY=\"<path>\"/c\SSH_KEY=/root/.ssh/id_rsa' /etc/default/kdump-tools")
            self.c.run_command("kdump-config unload;")
            self.c.run_command("kdump-config load;")
            time.sleep(5)
        else:
            self.c.run_command('sed -i \'/^KDUMP_SAVEDIR=/c\KDUMP_SAVEDIR=\"ssh:\/\/root:%s@%s\/%s\"\' /etc/sysconfig/kdump;' % (self.server_pw, self.server_ip, self.net_path))
            self.c.run_command("touch /etc/sysconfig/kdump; systemctl restart kdump.service; sync", timeout=600)
            time.sleep(5)


    def setup_nfs(self):
        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        if self.distro == "rhel":
            self.c.run_command("sed -i '/ssh root@%s/c\#ssh user@my.server.com' /etc/kdump.conf; sync" % self.server_ip)
            self.c.run_command("sed -i '/sshkey \/root\/.ssh\/id_rsa/c\#sshkey \/root\/.ssh\/kdump_id_rsa' /etc/kdump.conf; sync")
            self.c.run_command("yum -y install nfs-utils", timeout=600)
            self.c.run_command("service nfs-server start")
            self.c.run_command("echo 'nfs %s:%s' >> /etc/kdump.conf; sync" % (self.server_ip, self.net_path))
            self.c.run_command("sed -i 's/-l -F --message-level/-l --message-level/' /etc/kdump.conf; sync")
            self.c.run_command("sed -i '/path \/var\/crash/c\path \/' /etc/kdump.conf; sync")
            self.c.run_command("mount -t nfs %s:%s /var/crash" % (self.server_ip, self.net_path))
            self.c.run_command("cd /root; kdumpctl restart", timeout=600)
            self.c.run_command("fsfreeze -f /boot; fsfreeze -u /boot", timeout=600)
            res = self.c.run_command("service kdump status | grep active")
            if 'dead' in res:
                self.fail("Kdump service is not configured properly")
        elif self.distro == "ubuntu":
            self.c.run_command("apt-get install -y nfs-common;")
            self.c.run_command("apt-get install -y nfs-kernel-server;")
            self.c.run_command("service nfs-server start;")
            self.c.run_command("mount -t nfs %s:%s /var/crash;" % (self.server_ip, self.net_path))
            self.c.run_command("sed -e '/SSH/ s/^#*/#/' -i /etc/default/kdump-tools;")
            self.c.run_command("sed -i '/NFS=\"<nfs mount>\"/c\\NFS=\"%s:%s\"' /etc/default/kdump-tools" % (self.server_ip, self.net_path))
            time.sleep(5)
        else:
            self.c.run_command('sed -i \'/^KDUMP_SAVEDIR=/c\KDUMP_SAVEDIR=\"nfs:\/\/%s\%s\"\' /etc/sysconfig/kdump;' % (self.server_ip, self.net_path))
            self.c.run_command("zypper install -y nfs-kernel-server; service nfs start")
            self.c.run_command("mount -t nfs %s:%s /var/crash" % (self.server_ip, self.net_path))
            self.c.run_command("touch /etc/sysconfig/kdump; systemctl restart kdump.service; sync", timeout=600)
            time.sleep(5)

    def runTest(self):
        if not (self.server_ip or self.server_ip):
            raise self.skipTest("Provide --server-ip and --server-pw "
                                "for network dumps")
        pwd_less = self.c.run_command("ssh -o \"StrictHostKeyChecking no\" -o  \"NumberOfPasswordPrompts=0\" %s \"echo\"" % self.server_ip)
        if "Permission denied" in pwd_less or "Permission denied" in pwd_less[0]:
            raise self.skipTest("For Network dump cases please setup passwordless authentication between test machine and remote server")
        self.setup_test("net")
        self.setup_ssh()
        print("=============== Testing kdump/fadump over ssh ===============")
        boot_type = self.kernel_crash()
        self.verify_dump_file(boot_type, dump_place="net")
        self.setup_test("net")
        self.setup_nfs()
        print("=============== Testing kdump/fadump over nfs ===============")
        boot_type = self.kernel_crash()
        self.verify_dump_file(boot_type, dump_place="net")
        if self.distro == "rhel":
            self.c.run_command("sed -e '/nfs/ s/^#*/#/' -i /etc/kdump.conf; sync")
        elif self.distro == "ubuntu":
            self.c.run_command("sed -e '/NFS/ s/^#*/#/' -i /etc/default/kdump-tools;")

class KernelCrash_KdumpSMT(PowerNVDump):

    def runTest(self):
        self.cv_SYSTEM.goto_state(OpSystemState.OS)
        for i in ["off", "2", "4"]:
            self.setup_test()
            self.c.run_command("ppc64_cpu --smt=%s" % i)
            self.c.run_command("ppc64_cpu --smt")
            print("=============== Testing kdump/fadump with smt=%s ===============" % i)
            boot_type = self.kernel_crash()
            self.verify_dump_file(boot_type)
        self.setup_test()
        self.c.run_command("ppc64_cpu --cores-on=1", timeout=600)
        self.c.run_command("ppc64_cpu --cores-on")
        print("=============== Testing kdump/fadump with single core ===============")
        boot_type = self.kernel_crash()
        self.verify_dump_file(boot_type)
        self.setup_test()
        self.c.run_command("ppc64_cpu --cores-on=1", timeout=600)
        self.c.run_command("ppc64_cpu --smt=off")
        print("=============== Testing kdump/fadump with single cpu ===============")
        boot_type = self.kernel_crash()
        self.verify_dump_file(boot_type)
        if self.is_lpar:
            for i in ["off", "2", "4", "on"]:
                self.setup_test()
                self.c.run_command("ppc64_cpu --smt=%s" % i)
                self.c.run_command("ppc64_cpu --smt")
                print("=============== Testing kdump/fadump with smt=%s and dumprestart from HMC ===============" % i)
                boot_type = self.kernel_crash(crash_type="hmc")
                self.verify_dump_file(boot_type)

def crash_suite():
    s = unittest.TestSuite()
    s.addTest(KernelCrash_OnlyKdumpEnable())
    s.addTest(KernelCrash_KdumpSMT())
    s.addTest(KernelCrash_KdumpNetwork())
    s.addTest(KernelCrash_FadumpEnable())
    s.addTest(KernelCrash_KdumpSMT())
    s.addTest(KernelCrash_KdumpNetwork())
    s.addTest(KernelCrash_DisableAll())
    s.addTest(SkirootKernelCrash())
    s.addTest(OPALCrash_MPIPL())


    return s
